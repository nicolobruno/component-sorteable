{"ast":null,"code":"!function (e, o) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? o(exports, require(\"react\"), require(\"prop-types\"), require(\"d3-geo\"), require(\"topojson-client\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"react\", \"prop-types\", \"d3-geo\", \"topojson-client\"], o) : o((e = e || self).reactSimpleMaps = {}, e.React, e.PropTypes, e.d3Geo, e.topojson);\n}(this, function (e, o, n, t, r) {\n  \"use strict\";\n\n  var a = \"default\" in o ? o.default : o;\n  n = n && n.hasOwnProperty(\"default\") ? n.default : n;\n\n  var i = Object.assign || function (e) {\n    for (var o = 1; o < arguments.length; o++) {\n      var n = arguments[o];\n\n      for (var t in n) Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);\n    }\n\n    return e;\n  },\n      s = function (e, o) {\n    var n = {};\n\n    for (var t in e) o.indexOf(t) >= 0 || Object.prototype.hasOwnProperty.call(e, t) && (n[t] = e[t]);\n\n    return n;\n  },\n      u = function (e, o) {\n    if (Array.isArray(e)) return e;\n    if (Symbol.iterator in Object(e)) return function (e, o) {\n      var n = [],\n          t = !0,\n          r = !1,\n          a = void 0;\n\n      try {\n        for (var i, s = e[Symbol.iterator](); !(t = (i = s.next()).done) && (n.push(i.value), !o || n.length !== o); t = !0);\n      } catch (e) {\n        r = !0, a = e;\n      } finally {\n        try {\n          !t && s.return && s.return();\n        } finally {\n          if (r) throw a;\n        }\n      }\n\n      return n;\n    }(e, o);\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  },\n      c = o.createContext(),\n      l = {\n    geoEqualEarth: t.geoEqualEarth,\n    geoMercator: t.geoMercator,\n    geoTransverseMercator: t.geoTransverseMercator,\n    geoAlbers: t.geoAlbers,\n    geoAlbersUsa: t.geoAlbersUsa,\n    geoAzimuthalEqualArea: t.geoAzimuthalEqualArea,\n    geoAzimuthalEquidistant: t.geoAzimuthalEquidistant,\n    geoOrthographic: t.geoOrthographic,\n    geoConicConformal: t.geoConicConformal,\n    geoConicEqualArea: t.geoConicEqualArea,\n    geoConicEquidistant: t.geoConicEquidistant\n  },\n      d = function (e) {\n    var n = e.width,\n        r = e.height,\n        u = e.projection,\n        d = e.projectionConfig,\n        m = s(e, [\"width\", \"height\", \"projection\", \"projectionConfig\"]),\n        v = d.center || [],\n        p = d.rotate || [],\n        f = d.parallels || [],\n        g = d.scale || null,\n        h = o.useMemo(function () {\n      var e = function (e) {\n        var o = e.projectionConfig,\n            n = void 0 === o ? {} : o,\n            t = e.projection,\n            r = void 0 === t ? \"geoEqualEarth\" : t,\n            a = e.width,\n            i = void 0 === a ? 800 : a,\n            s = e.height,\n            u = void 0 === s ? 500 : s;\n        if (\"function\" == typeof r) return r;\n        var c = l[r]().translate([i / 2, u / 2]);\n        return [c.center ? \"center\" : null, c.rotate ? \"rotate\" : null, c.scale ? \"scale\" : null, c.parallels ? \"parallels\" : null].forEach(function (e) {\n          e && (c = c[e](n[e] || c[e]()));\n        }), c;\n      }({\n        projectionConfig: d,\n        projection: u,\n        width: n,\n        height: r\n      });\n\n      return {\n        width: n,\n        height: r,\n        projection: e,\n        path: t.geoPath().projection(e)\n      };\n    }, [n, r, u, v[0], v[1], p[0], p[1], p[2], f[0], f[1], g]);\n    return a.createElement(c.Provider, i({\n      value: h\n    }, m));\n  };\n\n  d.propTypes = {\n    width: n.number,\n    height: n.number,\n    projection: n.oneOfType([n.string, n.func]),\n    projectionConfig: n.object\n  };\n\n  var m = function (e) {\n    var o = e.width,\n        n = void 0 === o ? 800 : o,\n        t = e.height,\n        r = void 0 === t ? 600 : t,\n        u = e.projection,\n        c = void 0 === u ? \"geoEqualEarth\" : u,\n        l = e.projectionConfig,\n        m = void 0 === l ? {} : l,\n        v = e.className,\n        p = void 0 === v ? \"\" : v,\n        f = s(e, [\"width\", \"height\", \"projection\", \"projectionConfig\", \"className\"]);\n    return a.createElement(d, {\n      width: n,\n      height: r,\n      projection: c,\n      projectionConfig: m\n    }, a.createElement(\"svg\", i({\n      viewBox: \"0 0 \" + n + \" \" + r,\n      className: \"rsm-svg \" + p\n    }, f)));\n  };\n\n  function v(e, o) {\n    if (Array.isArray(e)) return o ? o(e) : e;\n    var n = r.feature(e, e.objects[Object.keys(e.objects)[0]]).features;\n    return o ? o(n) : n;\n  }\n\n  function p(e) {\n    var n = e.geography,\n        t = e.parseGeographies,\n        r = o.useContext(c).path,\n        a = o.useState(),\n        s = u(a, 2),\n        l = s[0],\n        d = s[1];\n    return o.useEffect(function () {\n      var e;\n      \"undefined\" != typeof window && (\"string\" == typeof n ? (e = n, fetch(e).then(function (e) {\n        if (!e.ok) throw Error(e.statusText);\n        return e.json();\n      }).catch(function (e) {\n        console.log(\"There was a problem when fetching the data: \", e);\n      })).then(function (e) {\n        e && d(v(e, t));\n      }) : d(v(n, t)));\n    }, [n]), {\n      geographies: o.useMemo(function () {\n        return function (e, o) {\n          return e ? e.map(function (e, n) {\n            return i({}, e, {\n              rsmKey: \"geo-\" + n,\n              svgPath: o(e)\n            });\n          }) : [];\n        }(l, r);\n      }, [l, r])\n    };\n  }\n\n  m.propTypes = {\n    width: n.number,\n    height: n.number,\n    projection: n.oneOfType([n.string, n.func]),\n    projectionConfig: n.object,\n    className: n.string\n  };\n\n  var f = function (e) {\n    var n = e.geography,\n        t = e.children,\n        r = e.parseGeographies,\n        u = e.className,\n        l = void 0 === u ? \"\" : u,\n        d = s(e, [\"geography\", \"children\", \"parseGeographies\", \"className\"]),\n        m = o.useContext(c),\n        v = m.path,\n        f = m.projection,\n        g = p({\n      geography: n,\n      parseGeographies: r\n    }).geographies;\n    return a.createElement(\"g\", i({\n      className: \"rsm-geographies \" + l\n    }, d), g && g.length > 0 && t({\n      geographies: g,\n      path: v,\n      projection: f\n    }));\n  };\n\n  f.propTypes = {\n    geography: n.oneOfType([n.string, n.object, n.array]),\n    children: n.func,\n    parseGeographies: n.func,\n    className: n.string\n  };\n\n  var g = function (e) {\n    var n = e.geography,\n        t = e.onMouseEnter,\n        r = e.onMouseLeave,\n        c = e.onMouseDown,\n        l = e.onMouseUp,\n        d = e.onFocus,\n        m = e.onBlur,\n        v = e.style,\n        p = void 0 === v ? {} : v,\n        f = e.className,\n        g = void 0 === f ? \"\" : f,\n        h = s(e, [\"geography\", \"onMouseEnter\", \"onMouseLeave\", \"onMouseDown\", \"onMouseUp\", \"onFocus\", \"onBlur\", \"style\", \"className\"]),\n        y = o.useState(!1),\n        E = u(y, 2),\n        b = E[0],\n        M = E[1],\n        j = o.useState(!1),\n        w = u(j, 2),\n        x = w[0],\n        N = w[1];\n    return a.createElement(\"path\", i({\n      role: \"geography\",\n      tabIndex: \"0\",\n      className: \"rsm-geography \" + g,\n      d: n.svgPath,\n      onMouseEnter: function (e) {\n        N(!0), t && t(e);\n      },\n      onMouseLeave: function (e) {\n        N(!1), b && M(!1), r && r(e);\n      },\n      onFocus: function (e) {\n        N(!0), d && d(e);\n      },\n      onBlur: function (e) {\n        N(!1), b && M(!1), m && m(e);\n      },\n      onMouseDown: function (e) {\n        M(!0), c && c(e);\n      },\n      onMouseUp: function (e) {\n        M(!1), l && l(e);\n      },\n      style: p[b || x ? b ? \"pressed\" : \"hover\" : \"default\"]\n    }, h));\n  };\n\n  g.propTypes = {\n    geography: n.object,\n    onMouseEnter: n.func,\n    onMouseLeave: n.func,\n    onMouseDown: n.func,\n    onMouseUp: n.func,\n    onFocus: n.func,\n    onBlur: n.func,\n    style: n.object,\n    className: n.string\n  };\n\n  var h = o.memo(g),\n      y = function (e) {\n    var n = e.fill,\n        r = void 0 === n ? \"transparent\" : n,\n        u = e.stroke,\n        l = void 0 === u ? \"currentcolor\" : u,\n        d = e.step,\n        m = void 0 === d ? [10, 10] : d,\n        v = e.className,\n        p = void 0 === v ? \"\" : v,\n        f = s(e, [\"fill\", \"stroke\", \"step\", \"className\"]),\n        g = o.useContext(c).path;\n    return a.createElement(\"path\", i({\n      d: g(t.geoGraticule().step(m)()),\n      fill: r,\n      stroke: l,\n      className: \"rsm-graticule \" + p\n    }, f));\n  };\n\n  y.propTypes = {\n    fill: n.string,\n    stroke: n.string,\n    step: n.array,\n    className: n.string\n  };\n  var E = o.memo(y);\n\n  function b(e) {\n    var n = e.center,\n        t = void 0 === n ? [0, 0] : n,\n        r = e.zoom,\n        a = void 0 === r ? 1 : r,\n        s = e.minZoom,\n        l = void 0 === s ? 1 : s,\n        d = e.maxZoom,\n        m = void 0 === d ? 5 : d,\n        v = e.zoomSensitivity,\n        p = void 0 === v ? .025 : v,\n        f = e.onZoomStart,\n        g = e.onZoomEnd,\n        h = e.onMoveStart,\n        y = e.onMoveEnd,\n        E = e.disablePanning,\n        b = void 0 !== E && E,\n        M = e.disableZooming,\n        j = void 0 !== M && M,\n        w = o.useContext(c),\n        x = w.width,\n        N = w.height,\n        L = w.projection,\n        z = o.useRef(null),\n        S = o.useState(function () {\n      var e = L(t);\n      return {\n        x: x / 2 - e[0] * a,\n        y: N / 2 - e[1] * a,\n        last: [x / 2 - e[0] * a, N / 2 - e[1] * a],\n        zoom: a,\n        dragging: !1,\n        zooming: !1\n      };\n    }),\n        T = u(S, 2),\n        C = T[0],\n        Z = T[1],\n        k = o.useRef(),\n        P = o.useRef(),\n        O = o.useRef(!1),\n        A = o.useRef();\n\n    function q(e) {\n      var o = k.current.closest(\"svg\");\n      e.targetTouches ? (P.current.x = e.targetTouches[0].clientX, P.current.y = e.targetTouches[0].clientY) : (P.current.x = e.clientX, P.current.y = e.clientY);\n      var n = o.getScreenCTM().inverse();\n      return P.current.matrixTransform(n);\n    }\n\n    function G(e) {\n      b || (O.current = !0, A.current = q(e), Z(function (o) {\n        return h && h(e, i({}, o, {\n          dragging: !0\n        })), i({}, o, {\n          dragging: !0\n        });\n      }));\n    }\n\n    function D(e) {\n      if (O.current) {\n        e.preventDefault();\n        var o = q(e);\n        Z(function (e) {\n          return i({}, e, {\n            x: e.last[0] + (o.x - A.current.x),\n            y: e.last[1] + (o.y - A.current.y)\n          });\n        });\n      }\n    }\n\n    function U(e) {\n      O.current = !1, Z(function (o) {\n        return y && y(e, i({}, o, {\n          last: [o.x, o.y],\n          dragging: !1\n        })), i({}, o, {\n          last: [o.x, o.y],\n          dragging: !1\n        });\n      });\n    }\n\n    function B(e) {\n      if (e.ctrlKey && !j) {\n        e.preventDefault();\n        var o = e.deltaY * p;\n        Z(function (n) {\n          var t = n.zoom - o,\n              r = t < l ? l : t > m ? m : t,\n              a = q(e),\n              s = (n.x - a.x) * r / n.zoom + a.x,\n              u = (n.y - a.y) * r / n.zoom + a.y;\n          return window.clearTimeout(z.current), z.current = setTimeout(function () {\n            Z(function (o) {\n              return g && g(e, o), i({}, o, {\n                zooming: !1\n              });\n            });\n          }, 66), f && f(e, i({}, n, {\n            x: s,\n            y: u,\n            last: [s, u],\n            zoom: r,\n            zooming: !0\n          })), i({}, n, {\n            x: s,\n            y: u,\n            last: [s, u],\n            zoom: r,\n            zooming: !0\n          });\n        });\n      }\n    }\n\n    return o.useLayoutEffect(function () {\n      var e = k.current.closest(\"svg\");\n      return P.current = e.createSVGPoint(), e.addEventListener(\"wheel\", B), window.PointerEvent ? (e.addEventListener(\"pointerdown\", G), e.addEventListener(\"pointerup\", U), e.addEventListener(\"pointerleave\", U), e.addEventListener(\"pointermove\", D)) : (e.addEventListener(\"mousedown\", G), e.addEventListener(\"mouseup\", U), e.addEventListener(\"mouseleave\", U), e.addEventListener(\"mousemove\", D), e.addEventListener(\"touchstart\", G), e.addEventListener(\"touchend\", U), e.addEventListener(\"touchmove\", D)), function () {\n        e.removeEventListener(\"wheel\", B), window.PointerEvent ? (e.removeEventListener(\"pointerdown\", G), e.removeEventListener(\"pointerup\", U), e.removeEventListener(\"pointerleave\", U), e.removeEventListener(\"pointermove\", D)) : (e.removeEventListener(\"mousedown\", G), e.removeEventListener(\"mouseup\", U), e.removeEventListener(\"mouseleave\", U), e.removeEventListener(\"mousemove\", D), e.removeEventListener(\"touchstart\", G), e.removeEventListener(\"touchend\", U), e.removeEventListener(\"touchmove\", D));\n      };\n    }, []), o.useEffect(function () {\n      Z(function (e) {\n        var o = (e.x - x / 2) * a / e.zoom + x / 2,\n            n = (e.y - N / 2) * a / e.zoom + N / 2;\n        return i({}, e, {\n          x: o,\n          y: n,\n          last: [o, n],\n          zoom: a\n        });\n      });\n    }, [a]), o.useEffect(function () {\n      var e = L(t);\n      Z(function (o) {\n        return i({}, o, {\n          x: x / 2 - e[0] * o.zoom,\n          y: N / 2 - e[1] * o.zoom,\n          last: [x / 2 - e[0] * o.zoom, N / 2 - e[1] * o.zoom]\n        });\n      });\n    }, [t[0], t[1]]), {\n      elRef: k,\n      position: C,\n      transformString: \"translate(\" + C.x + \" \" + C.y + \") scale(\" + C.zoom + \")\"\n    };\n  }\n\n  var M = function (e) {\n    var o = e.render,\n        n = e.children,\n        t = e.center,\n        r = void 0 === t ? [0, 0] : t,\n        u = e.zoom,\n        c = void 0 === u ? 1 : u,\n        l = e.minZoom,\n        d = void 0 === l ? 1 : l,\n        m = e.maxZoom,\n        v = void 0 === m ? 5 : m,\n        p = e.zoomSensitivity,\n        f = void 0 === p ? .025 : p,\n        g = e.onZoomStart,\n        h = e.onZoomEnd,\n        y = e.onMoveStart,\n        E = e.onMoveEnd,\n        M = e.disablePanning,\n        j = void 0 !== M && M,\n        w = e.disableZooming,\n        x = void 0 !== w && w,\n        N = e.className,\n        L = void 0 === N ? \"\" : N,\n        z = s(e, [\"render\", \"children\", \"center\", \"zoom\", \"minZoom\", \"maxZoom\", \"zoomSensitivity\", \"onZoomStart\", \"onZoomEnd\", \"onMoveStart\", \"onMoveEnd\", \"disablePanning\", \"disableZooming\", \"className\"]),\n        S = b({\n      center: r,\n      zoom: c,\n      minZoom: d,\n      maxZoom: v,\n      zoomSensitivity: f,\n      onZoomStart: g,\n      onZoomEnd: h,\n      onMoveStart: y,\n      onMoveEnd: E,\n      disablePanning: j,\n      disableZooming: x\n    }),\n        T = S.elRef,\n        C = S.position,\n        Z = S.transformString;\n    return a.createElement(\"g\", i({\n      ref: T,\n      className: \"rsm-zoomable-group \" + L\n    }, z), o ? o(C) : a.createElement(\"g\", {\n      transform: Z\n    }, n));\n  };\n\n  M.propTypes = {\n    render: n.func,\n    children: n.oneOfType([n.node, n.arrayOf(n.node)]),\n    center: n.array,\n    zoom: n.number,\n    minZoom: n.number,\n    maxZoom: n.number,\n    zoomSensitivity: n.number,\n    onZoomStart: n.func,\n    onZoomEnd: n.func,\n    onMoveStart: n.func,\n    onMoveEnd: n.func,\n    disablePanning: n.bool,\n    disableZooming: n.bool,\n    className: n.string\n  };\n\n  var j = function (e) {\n    var n = e.id,\n        t = void 0 === n ? \"rsm-sphere\" : n,\n        r = e.fill,\n        u = void 0 === r ? \"transparent\" : r,\n        l = e.stroke,\n        d = void 0 === l ? \"currentcolor\" : l,\n        m = e.strokeWidth,\n        v = void 0 === m ? .5 : m,\n        p = e.className,\n        f = void 0 === p ? \"\" : p,\n        g = s(e, [\"id\", \"fill\", \"stroke\", \"strokeWidth\", \"className\"]),\n        h = o.useContext(c).path,\n        y = o.useMemo(function () {\n      return h({\n        type: \"Sphere\"\n      });\n    }, [h]);\n    return a.createElement(o.Fragment, null, a.createElement(\"defs\", null, a.createElement(\"clipPath\", {\n      id: t\n    }, a.createElement(\"path\", {\n      d: y\n    }))), a.createElement(\"path\", i({\n      d: y,\n      fill: u,\n      stroke: d,\n      strokeWidth: v,\n      style: {\n        pointerEvents: \"none\"\n      },\n      className: \"rsm-sphere \" + f\n    }, g)));\n  };\n\n  j.propTypes = {\n    id: n.string,\n    fill: n.string,\n    stroke: n.string,\n    strokeWidth: n.number,\n    className: n.string\n  };\n\n  var w = o.memo(j),\n      x = function (e) {\n    var n = e.coordinates,\n        t = e.children,\n        r = e.onMouseEnter,\n        l = e.onMouseLeave,\n        d = e.onMouseDown,\n        m = e.onMouseUp,\n        v = e.onFocus,\n        p = e.onBlur,\n        f = e.style,\n        g = void 0 === f ? {} : f,\n        h = e.className,\n        y = void 0 === h ? \"\" : h,\n        E = s(e, [\"coordinates\", \"children\", \"onMouseEnter\", \"onMouseLeave\", \"onMouseDown\", \"onMouseUp\", \"onFocus\", \"onBlur\", \"style\", \"className\"]),\n        b = o.useContext(c).projection,\n        M = o.useState(!1),\n        j = u(M, 2),\n        w = j[0],\n        x = j[1],\n        N = o.useState(!1),\n        L = u(N, 2),\n        z = L[0],\n        S = L[1],\n        T = b(n),\n        C = u(T, 2),\n        Z = C[0],\n        k = C[1];\n    return a.createElement(\"g\", i({\n      transform: \"translate(\" + Z + \", \" + k + \")\",\n      className: \"rsm-marker \" + y,\n      onMouseEnter: function (e) {\n        S(!0), r && r(e);\n      },\n      onMouseLeave: function (e) {\n        S(!1), w && x(!1), l && l(e);\n      },\n      onFocus: function (e) {\n        S(!0), v && v(e);\n      },\n      onBlur: function (e) {\n        S(!1), w && x(!1), p && p(e);\n      },\n      onMouseDown: function (e) {\n        x(!0), d && d(e);\n      },\n      onMouseUp: function (e) {\n        x(!1), m && m(e);\n      },\n      style: g[w || z ? w ? \"pressed\" : \"hover\" : \"default\"]\n    }, E), t);\n  };\n\n  x.propTypes = {\n    coordinates: n.array,\n    children: n.oneOfType([n.node, n.arrayOf(n.node)]),\n    onMouseEnter: n.func,\n    onMouseLeave: n.func,\n    onMouseDown: n.func,\n    onMouseUp: n.func,\n    onFocus: n.func,\n    onBlur: n.func,\n    style: n.object,\n    className: n.string\n  };\n\n  var N = function (e) {\n    var n = e.from,\n        t = void 0 === n ? [0, 0] : n,\n        r = e.to,\n        u = void 0 === r ? [0, 0] : r,\n        l = e.coordinates,\n        d = e.stroke,\n        m = void 0 === d ? \"currentcolor\" : d,\n        v = e.strokeWidth,\n        p = void 0 === v ? 3 : v,\n        f = e.fill,\n        g = void 0 === f ? \"transparent\" : f,\n        h = e.className,\n        y = void 0 === h ? \"\" : h,\n        E = s(e, [\"from\", \"to\", \"coordinates\", \"stroke\", \"strokeWidth\", \"fill\", \"className\"]),\n        b = o.useContext(c).path,\n        M = {\n      type: \"LineString\",\n      coordinates: l || [t, u]\n    };\n    return a.createElement(\"path\", i({\n      d: b(M),\n      className: \"rsm-line \" + y,\n      stroke: m,\n      strokeWidth: p,\n      fill: g\n    }, E));\n  };\n\n  N.propTypes = {\n    from: n.array,\n    to: n.array,\n    coordinates: n.array,\n    stroke: n.string,\n    strokeWidth: n.number,\n    fill: n.string,\n    className: n.string\n  };\n\n  var L = function (e) {\n    var n = e.subject,\n        t = e.children,\n        r = e.connectorProps,\n        l = e.dx,\n        d = void 0 === l ? 30 : l,\n        m = e.dy,\n        v = void 0 === m ? 30 : m,\n        p = e.curve,\n        f = void 0 === p ? 0 : p,\n        g = e.className,\n        h = void 0 === g ? \"\" : g,\n        y = s(e, [\"subject\", \"children\", \"connectorProps\", \"dx\", \"dy\", \"curve\", \"className\"]),\n        E = (0, o.useContext(c).projection)(n),\n        b = u(E, 2),\n        M = b[0],\n        j = b[1],\n        w = function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 30,\n          o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 30,\n          n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .5,\n          t = Array.isArray(n) ? n : [n, n];\n      return \"M0,0 Q\" + (-e / 2 - e / 2 * t[0]) + \",\" + (-o / 2 + o / 2 * t[1]) + \" \" + -e + \",\" + -o;\n    }(d, v, f);\n\n    return a.createElement(\"g\", i({\n      transform: \"translate(\" + (M + d) + \", \" + (j + v) + \")\",\n      className: \"rsm-annotation \" + h\n    }, y), a.createElement(\"path\", i({\n      d: w,\n      fill: \"transparent\",\n      stroke: \"#000\"\n    }, r)), t);\n  };\n\n  L.propTypes = {\n    subject: n.array,\n    children: n.oneOfType([n.node, n.arrayOf(n.node)]),\n    dx: n.number,\n    dy: n.number,\n    curve: n.number,\n    connectorProps: n.object,\n    className: n.string\n  }, e.Annotation = L, e.ComposableMap = m, e.Geographies = f, e.Geography = h, e.Graticule = E, e.Line = N, e.Marker = x, e.Sphere = w, e.ZoomableGroup = M, e.useGeographies = p, e.useZoomPan = b, Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"script"}